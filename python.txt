python is a case sensitive language.
REPl -> read evaluate print loop


Character set ->
1) letters - A to Z, a to z 
2) Digits - 0 to 9
3) special symbols - +,-,*,/ etc
4) whitespaces - blank space, tab, carriage return, new line,formfeed
5) other Characters - python can process all ASCII and Unicode characters as part of data or literals.


variables -> a variable is a name given to a memory location in a program.
eg. -> name = "anu , age = 23
rules for identifiers ->
1) identifiers can be combination of uppercase and lowercase letters, dgits or an underscore. 
2) an identifier can not start with digit. so 1variable is not valid
3) we can't use special symbols like !,@,#,$,% etc in our identifier.
4) identifier can be of any length.


data types -> integers, string('anu',"anu", '''anu'''), float, boolean, none


comments -> 
1) # single line comment
2) """
multiline 
comment
"""


types of operators -> an operator is a symbol that performs a centain operation b/w operands
1) arithmetic operators
2) relational/comparison operators
3) assignment operators
4) logical operators



type conversion ->
1) implicit -> automatically
2) casting -> manually



input -> input() statement is used to accept value (using keyword) from user 
input() -> #result for input() is always a string
int(input()) -> for int
float(input()) -> for float 



strings -> string is data type that stores a sequence of characters.
the indexing starts from 0 to length-1 when we start from the starting point/index.
the negative indexing start from -1 to length-1 in decreasing order , when we start from the end point/index.
basic operations -> 
1) concatenation -> eg. - "hello" + "world" = "helloworld"
2) length of string -> len(str)



escape sequence characters -> sequence of characters after backslash "\".
escape sequence characters comprise of more than one character but represent one character when used within the strings.
\n -> newline
\t -> tab 
\' -> single quote
\\ -> backslash 



conditional statement->
syntax -> if-elif-else



indentation -> means proper spacing, in any other language we use block for writing may lines of code but here be use indentation.



list -> A built-in data type that stores set of values.
it can store elements of different type(integer,float,string etc).
lists are mutable,strings are immutable.



tuples -> A built-in data type that lets us create immutable sequences of values.



dictionary -> # dictionaries are used to store data values in "key":value pairs.
# they  are unordered, mutable(changesable) & don't allow duplicate keys
# eg. -> creation of dictionary 
# dict = {
#  "name" : "anu",
#  "CGPA" : 7.8,
#  "marks" : [85,90,87]
# }




sets -> set is the collection of the unordered items.
each element in the set must be unique & immutable.
enpty set syntax -> num = set()
eg. ->
nums = {1,2,2,2,3}
repeated elements stored only once, so it resolved to {1,2,3}




while loop -> loops are used to repeat instructions.
iteration -> one time whole loop code runs
iterator -> variable name whose used for condition
syntax
while condition:
 some work

break -> used to terminate the loop when encountered
continue -> terminates exicution in the current iteration and continues execution of the loop with next iteration




for loop -> loops are used for sequential traversal
syntax ->
for ele in list:
 some work

for loop with else
here else is work while whole loop is exicute,if we break the loop at specific condition so this else does not work
for ele in list:
 some work
else:
 work when loop ends 






function -> block of statements that perform a specif task.
1) function definition
def fun_name(param1,param2,...):
 some work
 return value
2) function call 
fun_name(arg1,arg2,...)

types of functions
1) built-in functions -> print() function ends with new line(\n),if we wants to print some lines in same line so we can assign (end = " "), eg.-> print("anu",end=" ")   print("jain"), output-> anu jain
2) user define function

default parameters -> assigning a default value to parameter, which is used when no argument is passed





File I/O -> python can be used to perform operations on a file.(read and write data)
type of files ->
1) text files -> .txt, .docx, .log etc.
2) binary files -> .mp4, .mov, .png, .jpeg etc.
open, read & close file -> we have to open a file before reading or writing
eg. -> 
f = open("fine_name","mode")    #file_bame -> sample.txt,demo.docx     #mode -> r-read mode, w-write mode
data = f.read()
f.close()

character           meaning
   'r'         open for reading(default)
   'w'         open for writing, truncatin the file first(overwrite the content of the file)
   'x'         create a new file anf open it for writing
   'a'         open for writing, appending to the end of the file if it exixts
   'b'         binary mode 
   't'         text mode(default) 
   '+'         open a disk file for uploading(reading and writing)

with syntax ->
with open("file name","mode") as f:
 variable_name = f.read()

deleting a file -> using the os module.
module(like a code library) is a file writing by another programmer that generally has a function we can use. 
import os 
os.remove(filename) 






OOP -> To map  with real world scenarios,we started using object in code. 
this is called object oriented programming.

class -> class is a blueprint for creating objects.
creating class -> 
 class Student:
  name = "anu jain"

creating object(instance) 
s1 = Student()
print(s1.name)

constructor (_ _init_ _ function) -> all classes have a function called __init__(), which is always executed when the object is being initiated.
'the self parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class.'
# creating class
class Student:
 def __init__(self,fullname):
  self.name = fullname
# creating object
s1 = Student("karan")
print(s1.name) 


static method -> methods that don't use the self parameter(work at class level).
class Student:
 @staticmethod    #decorator
 def collage():
  print("ABC Collage")

'Decorators allow us to wrap another function in order to extend the behaviour of the wrapped function,without permanently modifying it.'  




Abstraction -> hiding the implementation details of a class and only showing the essential features to the user. 

encapsulation -> wrapping data and functions into  a single unit (object).



private(like) attributes and methods -> conceptual implementation in python -> private attributes and methods are meant to be used only within the class and not accessible from outside the class 




class method -> A class method is bound to the class and receives the class  as an implicit first argument. 
Note -> static method can't access or modify class state and generally for utility. 
eg. ->
class Student:
 @classmethod          #decorator
 def collage(cls):
  pass







types of methods -> 
1) static method -> here we can't change class or instance method attributes.
2) class method -> here we pass "cls" as an argument.
3) instance method -> here we pass "self" as an argument. 






polymorphism : operator overloading -> when the same operator is allowing to have diffrent meaning according to the context.
operator & dunder functions -> 
1) addition            a+b              a.__add__(b)
2) subtraction         a+b              a.__sub__(b)
3) multiplication      a+b              a.__mul__(b)
4) division            a+b              a.__truediv__(b)
5) mod                 a+b              a.__mod__(b)
6) comparision         a>b              a.__gt__(b) 






use of addition operator for different data types -> 
print(1+2) #add numbers
print("anu "+"jain")   #concatenate
print([1,2,3],[4,5,6])  #merge





special variable = __name__
special method = __init__




size of an object -> depends on the no. of variable and size of each variable.
who allocate size of object -> constructor




multilinr statement -> 
here / shows line does not ends
a = 1+2+3+/
    4+5+6+/
    7+8